## CWE-352: Cross-Site Request Forgery (CSRF)
- https://cwe.mitre.org/data/definitions/352.html

---
## Descrição
Um CSRF token é um código alfanumérico, aleatório e secreto, que pode ser gerado para cada sessão ou para cada pedido HTTP. É enviado ao browser (cliente), que o entrega de volta ao servidor, quando o formulário é submetido. Deste modo, é possível assegurar que um pedido é seguro.

Quando um POST é enviado sem este token ou com um que não corresponde ao da sessão atual, o servidor não tem como garantir que foi enviado pelo browser do utilizador e não por uma entidade maliciosa.

A ausência deste token constitui, portanto, uma vulnerabilidade.

---
## Explorar a vulnerabilidade

Na aplicação insegura, nem as páginas enviam um CSRF token, nem o servidor confirma a sua existência.

Aproveitando a vulnerabildidade [Unverified Password Change](CWE-620.md) e sabendo o email de um utilizador, é possível alterar-lhe a password, sem saber a atual, com um POST para a página das *Account Settings*. Para isso, não é necessário estar autenticado nem sequer estar no website, uma vez que o CSRF token não é verificado pelo servidor.

Usando o comando ```curl```, para enviar pedidos HTTP na linha de comandos do sistema operativo, é possível explorar esta vulnerabilidade.

**Código exemplo**:

PEDIDO:
```bash
# Ataque CSRF bem-sucedido: alterar a password do utilizador com email "u1@ua.pt" para "xyz"
curl -X POST http://localhost:[PORT]/settings -H "Content-Type: application/x-www-form-urlencoded" -d "email=u1@ua.pt&new_password=xyz"
```
RESPOSTA:
```html
<!-- A resposta é um redirect para a página de login, o que significa que a password foi alterada -->
<!doctype html>
<html lang=en>
<title>Redirecting...</title>
<h1>Redirecting...</h1>
<p>You should be redirected automatically to the target URL: <a href="/login">/login</a>. If not, click the link.
```

## Solução

Para protegermos a nossa aplicação deste tipo de ataques, instalámos a biblioteca ```Flask-WTF```, que inclui uma classe ```CSRFProtec``` que ativa a proteção global de uma aplicação Flask contra CSRF.
```python
from flask_wtf.csrf import CSRFProtect
app = Flask(__name__)
csrf = CSRFProtect(app)
```

Depois de ativar o mecanismo, é necessário que todos os pedidos POST, geralmente provenientes da submissão de formulários, incluam um CSRF token. Para isso, adicionou-se um *hidden input* a cada formulário:
```html
<input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
```

Se tentarmos explorar novamente a vulnerabilidade, o servidor não aceita o pedido.

**Código exemplo**:

PEDIDO:
```bash
# Ataque CSRF sem sucesso: alterar a password do utilizador com email "u1@ua.pt" para "xyz"
curl -X POST http://localhost:[PORT]/settings\
-H "Content-Type: application/x-www-form-urlencoded"\
-d "email=u1@ua.pt&new_password=xyz"
```
RESPOSTA:
```html
<!-- Bad Request: o pedido não inclui o CSRF token -->
<!doctype html>
<html lang=en>
<title>400 Bad Request</title>
<h1>Bad Request</h1>
<p>The CSRF token is missing.</p>
```